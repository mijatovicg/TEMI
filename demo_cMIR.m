clear; close all; clc;

% Script demo_cMIR.m demonstrates the application of the corrected Mutual Information Rate (cMIR) estimator on
% the uncoupled point processes X and Y generated by Poisson distribution, as it is described in the SubSection 3.1.1 Simulation 1 of the main article [REF1]. 

% The function spiSeMe_surrogate_jodi.m used to generate surrogates of inter-event-intervals sequences is part of the SpiSeMe package, see [REF2].

%	[REF1]:
    % Mijatovic G, Pernice R, Perinelli A, Antonacci Y, Javorka M, Ricci L and Faes L (2021) Measuring the Rate of Information Exchange in Point-Process
    % Data With Application to Cardiovascular Variability. Front. Netw. Physiol. 1:765332. doi: 10.3389/fnetp.2021.765332
%	[REF2]:
   % A. Perinelli, M. Castelluzzo, L. Minati and L. Ricci, SpiSeMe: A multi-language package for spike train surrogate generation, 
   % Chaos 30 (2020), 073120, doi: 10.1063/5.0011328
   % The SpiSeMe package is available at https://github.com/LeonardoRicci/SpiSeMe.

%	This script is part of the TEMI package.

%% input parameters - MIR estimator
Nu = 1; % number of randomly generated events equal to number of target ecents
k_global = 30; % minimum number of the nearest neighbors to consider it any set
l_param = 1; % history embeddings lenght
num_surr = 100; % number of surrogates
%% spike trains
rate = 1; T = 100;
spike_train1 = generatePoisson(rate, T); 
spike_train2 = generatePoisson(rate, T); 

%% =============== MUTUAL INFORMATION RATE (MIR) ESTIMATION ===============
%% TE rate 2 --> 1 (spike_train1: target, spike_train2: driver)
spike_train_target = spike_train2;
spike_train_driver = spike_train1;

%random events inside of each interval
random_events = [];
for st = 1 : numel(spike_train_target)-1
    start_lim = spike_train_target(st);
    end_lim = spike_train_target(st+1);
    random_events = [random_events; (end_lim-start_lim).*rand(Nu,1) + start_lim];
end

% TER
tau  = spike_train_target(end, :) - spike_train_target(1, :); % total recording duration!
lambda_21 = numel(spike_train_target)/tau; % average firing rate
[Cx, Jx, Cu_x, Ju_x] = function_embedding_vectors(spike_train_target, spike_train_driver, l_param, random_events); % create embeddings
TER_21 = function_TE_rate(Cx, Jx, Cu_x, Ju_x, lambda_21, k_global);

% TERs over the surrogates distribution
TER_surr_jodi_21 = f_TER_surr_jodi(spike_train_target, spike_train_driver, num_surr, Nu, l_param, k_global); % TER over surrogates

%% TE rate 1 --> 2 (spike_train1: target, spike_train2: driver)
spike_train_target = spike_train1;
spike_train_driver = spike_train2;

% random events inside of each interval
random_events = [];
for st = 1 : numel(spike_train_target)-1
    start_lim = spike_train_target(st);
    end_lim = spike_train_target(st+1);
    random_events = [random_events; (end_lim-start_lim).*rand(Nu,1) + start_lim];
end

% TER
tau  = spike_train_target(end, :) - spike_train_target(1, :); % total recording duration!
lambda_12 = numel(spike_train_target)/tau; % average firing rate
[Cx, Jx, Cu_x, Ju_x] = function_embedding_vectors(spike_train_target, spike_train_driver, l_param, random_events); % create embeddings
TER_12 = function_TE_rate(Cx, Jx, Cu_x, Ju_x, lambda_12, k_global);

% TERs over the surrogates distribution
TER_surr_jodi_12 = f_TER_surr_jodi(spike_train_target, spike_train_driver, num_surr, Nu, l_param, k_global); % TER over surrogates

%% MIR
MIR = TER_21 + TER_12;
MIR_surr_jodi = TER_surr_jodi_21 + TER_surr_jodi_12;

%% Corrected MIR
cMIR = MIR - median(MIR_surr_jodi);

disp(strcat('MIR=', num2str(MIR), '[nats/s]'));
disp(strcat('cMIR=', num2str(cMIR), '[nats/s]'));


